% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/my_code.R
\name{SMC.Full.RB}
\alias{SMC.Full.RB}
\title{Generic Sequential Monte Carlo Using Full Information Proposal Distribution and Rao-Blackwellization}
\usage{
SMC.Full.RB(SISstep.Full.RB, nobs, yy, mm, par, xx.init, xdim, ydim,
  resample.sch)
}
\arguments{
\item{SISstep.Full.RB}{a function that performs one step propagation using a proposal distribution.
Its input includes \code{(mm,xx,logww,yyy,par,xdim,ydim,resample)}, where
\code{xx} and \code{logww} are the last iteration samples and log weight. \code{yyy} is the
observation at current time step. It should return \code{xx} (the samples xt) and
\code{logww} (their corresponding log weight), \code{resample} is a binary value for resampling.}

\item{nobs}{the number of observations \code{T}.}

\item{yy}{the observations with \code{T} columns and \code{ydim} rows.}

\item{mm}{the Monte Carlo sample size \code{m}.}

\item{par}{a list of parameter values to pass to \code{Sstep}.}

\item{xx.init}{the initial samples of \code{x_0}.}

\item{xdim}{the dimension of the state varible \code{x_t}.}

\item{ydim}{the dimension of the observation \code{y_t}.}

\item{resample.sch}{a binary vector of length \code{nobs}, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step \code{i}.}
}
\value{
The function returns a list with the following components:
\item{xhat}{the fitted values.}
\item{xhatRB}{the fitted values using Rao-Blackwellization.}
}
\description{
Generic sequential Monte Carlo using full information proposal distribution with Rao-Blackwellization estimate, and delay is 0.
}
\examples{
nobs <- 100; pd <- 0.95; ssw <- 0.15; ssv <- 0.02;
xx0 <- 0; ss0 <- 0.1; nyy <- 10; yrange <- c(-80,80);
xdim <- 2; ydim <- nyy; nk <- 5
yr <- yrange[2]-yrange[1]
par <- list(ssw=ssw,ssv=ssv,nyy=nyy,pd=pd,yr=yr)
Yy10 <- array(dim=c(nyy,nobs,nk))
Xx10 <- matrix(ncol=nk,nrow=nobs)
Ii10 <- matrix(ncol=nk,nrow=nobs)
kk <- 0
seed.k <- 1
while(kk < nk){
	seed.k <- seed.k+1
	set.seed(seed.k)
	kk <- kk+1
	simu <- simuTargetClutter(nobs,pd,ssw,ssv,xx0,ss0,nyy,yrange)
	if(max(abs(simu$yy))>80){
		kk <- kk-1
	}else{
		Xx10[,kk] <- simu$xx; Yy10[,,kk] <- simu$yy; Ii10[,kk] <- simu$ii
	}
}
resample.sch <- rep.int(1,nobs)
delay <- 0; mm <- 2000; 
Xxhat.p10 <- array(dim=c(nobs,1,nk))
Xxhat.RB10 <- array(dim=c(nobs,2,nk))
Xres.com1.10 <- array(dim=c(nobs,3,nk))
Xres.com2.10 <- array(dim=c(nobs,4,nk))
for(kk in 1:nk){
	xx.init <- matrix(nrow=2,ncol=mm)
	xx.init[1,] <- yrange[1]+runif(mm)*yr
	xx.init[2,] <- rep(0.1,mm)
	out3 <- SMC.Full.RB(Sstep.Clutter.Full.RB,nobs,Yy10[,,kk],mm,par,
	xx.init,xdim,ydim,resample.sch)
	Xxhat.RB10[,1,kk] <- out3$xhatRB[1,]
	Xxhat.RB10[,2,kk] <- out3$xhat[1,]
}
}
\references{
Tsay, R. and Chen, R. (2019). Nonlinear Time Series Analysis. Wiley, New Jersey.
}
