% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/my_code.R
\name{MKFstep.fading}
\alias{MKFstep.fading}
\title{One Propagation Step under Mixture Kalman Filter for Fading Channels}
\usage{
MKFstep.fading(mm, II, mu, SS, logww, yyy, par, xdim, ydim, resample)
}
\arguments{
\item{mm}{the Monte Carlo sample size.}

\item{II}{the indicators.}

\item{mu}{the mean in the last iteration.}

\item{SS}{the covariance matrix of the Kalman filter components in the last iteration.}

\item{logww}{is the log weight of the last iteration.}

\item{yyy}{the observations with \code{T} columns and \code{ydim} rows.}

\item{par}{a list of parameter values. \code{HH} is the state coefficient matrix, \code{WW*t(WW)} is the state innovation covariance matrix,
\code{VV*t(VV)} is the covariance matrix of the observation noise, \code{GG1} and \code{GG2} are the observation coefficient matrix.}

\item{xdim}{the dimension of the state varible \code{x_t}.}

\item{ydim}{the dimension of the observation \code{y_t}.}

\item{resample}{a binary vector of length \code{obs}, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step \code{i}.}
}
\value{
The function returns a list with components:
\item{xhat}{the fitted value.}
\item{xhatRB}{the fitted value using Rao-Blackwellization.}
\item{Iphat}{the estimated indicators.}
\item{IphatRB}{the esitmated indicators using Rao-Blackwellization.}
}
\description{
This function implements the one propagation step under mixture Kalman filter for fading channels.
}
\examples{
HH <- matrix(c(2.37409, -1.92936, 0.53028,0,1,0,0,0,0,1,0,0,0,0,1,0),ncol=4,byrow=TRUE)
WW <- matrix(c(1,0,0,0),nrow=4)
GG <- matrix(0.01*c(0.89409,2.68227,2.68227,0.89409),nrow=1)
VV <- 1.3**15*0.001
par <- list(HH=HH,WW=WW,GG=GG,VV=VV)
set.seed(1)
simu <- simu_fading(200,par)
GG1 <- GG; GG2 <- -GG
xdim <- 4; ydim <- 1
nobs <- 10050
mm <- 100; resample.sch <- rep(1,nobs)
kk <- 5
SNR <- 1:kk; BER1 <- 1:kk; BER0 <- 1:kk; BER.known <- 1:kk
tt <- 50:(nobs-1)
for(i in 1:kk){
VV <- 1.3**i*0.001
par <- list(HH=HH,WW=WW,GG=GG,VV=VV)
par2 <- list(HH=HH,WW=WW,GG1=GG1,GG2=GG2,VV=VV)
set.seed(1)
simu <- simu_fading(nobs,par)
mu.init <- matrix(0,nrow=4,ncol=mm)
SS0 <- diag(c(1,1,1,1))
for(n0 in 1:20){
SS0 <- HH\%*\%SS0\%*\%t(HH)+WW\%*\%t(WW)
}
SS.init <- aperm(array(rep(SS0,mm),c(4,4,mm)),c(1,2,3))
II.init <- floor(runif(mm)+0.5)+1
out <- MKF.Full.RB(MKFstep.fading,nobs,simu$yy,mm,par2,II.init,
mu.init,SS.init,xdim,ydim,resample.sch)
SNR[i] <- 10*log(var(simu$yy)/VV**2-1)/log(10)
Strue <- simu$ss[2:nobs]*simu$ss[1:(nobs-1)]
Shat <- rep(-1,(nobs-1))
Shat[out$IphatRB[2:nobs]>0.5] <- 1
BER1[i] <- sum(abs(Strue[tt]-Shat[tt]))/(nobs-50)/2
Shat0 <- sign(simu$yy[1:(nobs-1)]*simu$yy[2:nobs])
BER0[i] <- sum(abs(Strue[tt]-Shat0[tt]))/(nobs-50)/2
S.known <- sign(simu$yy*simu$alpha)
Shat.known <- S.known[1:(nobs-1)]*S.known[2:nobs]
BER.known[i] <- sum(abs(Strue[tt]-Shat.known[tt]))/(nobs-50)/2
}
}
\references{
Tsay, R. and Chen, R. (2018) Nonlinear Time Series Analysis.
}
